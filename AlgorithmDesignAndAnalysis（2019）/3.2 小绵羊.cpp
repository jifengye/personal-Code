/*
算法设计与分析3.2 小绵羊
★题目描述
本期活动中，共有N件商品参与促销。顾客可以直接选择M件拿走。
但是，拿走商品有一定的限制，某些商品不能被直接拿走，如果想要拿走他，必须要先拿走他指定的另一件特定商品。
请你计算一下，最多能够拿走总价值为多少的商品。


★输入格式
第一行包括两个正整数N， M，表示共有N件商品，你可以拿走M件。
接下来的N行，每i行包括两个自然数Ai，Bi。
若A = 0， 则表示该商品能直接拿走，若A != 0，则代表你需要先拿走第A个商品。
Bi代表该商品的价值。商品编号从1开始。
输入保证商品之间不会出现环。

★输出格式
输出仅包括一个正整数，表示你能拿走的最大总价值。

★输入样例
3 2
0 1
0 2
0 3
★输出样例
5

★HINT
对于100%的数据，1<=N，M<=300,0<=Bi<=1e6.
*/ 

/*
思路二：
	先虚构出0节点，那么这就是一个完整的树。
	约束是只有得到父节点，才能得到子节点。
 	参考依赖背包的做法，使用邻接表保存这棵树
	但是本题中没有背包容量约束，只是限定取个数，因此每次都取价值最大的商品
	动态规划使用 F[父节点][个数]：在购买了当前父节点情况下，再买m-1个子节点商品所能得到的最大价值
	里对于树中的每个节点来说，就是一个分组背包问题。每个子节点是一组物品。 
	我们从叶子节点往上到根节点规划，当规划到 0 节点时，F[0][m]即为我们所求 
	
复习邻接表
	假设有一棵树如下： 
		    0 
		1   2   3
 	  4 5	6  7 8

	用邻接表可以写成
	 H   NE
	 0   3 2 1 -1
	 1   5 4 -1
	 2   6 -1
	 3   8 7 -1
	 4   -1
*/ 
#include<bits/stdc++.h> 
using namespace std;
int N,M; //物品件数，每人限购个数 
int H[301], NE[301]; //用邻接表保存树结构，H保存邻接表的头，NE是有共同起点下的另一条边 
int W[301]; //物品的价值 
int F[301][301]; //前一维存放父节点、后一维存放每人限购件数 


void dfs(int p){
	for(int i=H[p]; i!=-1; i=NE[i]){ //p是父节点商品序号，所有i都是其子节点商品序号 
		dfs(i);
		for(int m=M; m>=1; --m){//因为要留出一个买父节点p的物品，所以只能分配出2~m个给子节点商品 
			for(int m2=0; m2<=m; ++m2){ //接着再分，每个子节点能得到的分配到的个数是m2 
				F[p][m]=max(F[p][m], F[p][m-m2]+F[i][m2]);
			}
		} 
	}
    for(int m=M; m>=1; --m) F[p][m] = F[p][m-1]+W[p]; //这里要加上P节点的价值哦 
} 

int main(){
	cin>>N>>M;
	
	//构建邻接表 
	memset(H, -1, sizeof(H)); 
	int p; 
	for(int i=1; i<=N; ++i){
		scanf("%d%d",&p,&W[i]);
		NE[i]=H[p];
		H[p]=i;	
	}

	W[0]=0;//虚构0节点
	++M; //因为加上虚构节点，所以购买个数要加1 
	memset(F, 0, sizeof(F));
	dfs(0);
	
	cout<<F[0][M]<<endl;
	return 0;
}